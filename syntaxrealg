local httpService = game:GetService("HttpService")
local proxyUrl = "http://bot-service-asia-se-02.cybrancee.com:5050/get-data" -- Replace with your server URL
local deleteUrl = "http://bot-service-asia-se-02.cybrancee.com:5050/delete-user" -- Replace with your server URL
local updateMoneyDropUrl = "http://bot-service-asia-se-02.cybrancee.com:5050/update-currentmoneydrop" -- New endpoint URL

local MainEvent = game.ReplicatedStorage:WaitForChild("MainEvent")  -- Adjust path to your RemoteEvent
local dropAmount = 10000
local netAmount = 8500  -- Net amount after tax
local cooldown = 16  -- Cooldown in seconds

-- List of alt account user IDs
local altAccountUserIds = {
    3068220681,
    3083889210,
    3083891022,
    3083892540,
    3083894051,
    3083895514,
    3301167626,
    3301171525,
    3301172896,
    3301175464,
    3301176405,
    3301177451,
    3301178340,
    3301179293,
    3301180270,
    3301181373,
    3301182850,
    3301184471,
    3301185659,
    3301187082,
    3301188358,
    3301189447,
    3301191149,
    3301192472,
    3301195894,
    3301197318,
    3301198667,
    3301200132,
    7123295683,
    7123302534,
    7123302053,
    7123300155,
    7123304506,
    7123294244,
    7123304512,
    7123303029
}

-- Base position for teleportation
local baseCFrame = CFrame.new(-389.909851, 21.2499924, -325.149384)
local offset = Vector3.new(16, 0, 0) -- Offset for each additional account


-- Initialize TextChatService
local textChatService = game:GetService("TextChatService")

-- Function to send a chat message
local messageSent = false

local function sendChatMessage(message)
    if not messageSent then
        -- Get the player's character
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()

        -- Use the Chat service to send a message
        game:GetService("Chat"):Chat(character.Head, message, Enum.ChatColor.Blue)
        
        -- Set the flag to true to indicate that the message has been sent
        messageSent = true
    end
end

-- Function to convert amount string to number
local function convertAmount(amountStr)
    local amount = tonumber(amountStr:sub(1, -2))
    local unit = amountStr:sub(-1):upper()
    if unit == "M" then
        return amount * 1e6
    elseif unit == "K" then
        return amount * 1e3
    else
        return amount
    end
end

-- Function to fetch data from the server
local function fetchData()
    local response = request({
        Url = proxyUrl,
        Method = "GET",
        Headers = {
            ["Content-Type"] = "application/json"
        }
    })
    
    if response.StatusCode == 200 then
        local data = httpService:JSONDecode(response.Body)
        return data
    else
        error("Failed to fetch data: " .. response.StatusCode .. " " .. response.StatusMessage)
    end
end

-- Function to delete user data from the server
local function deleteUser(username)
    local headers = {
        ["Content-Type"] = "application/json"
    }
    local data = {
        ["username"] = username
    }
    local body = httpService:JSONEncode(data)
    local response = request({
        Url = deleteUrl,
        Method = "POST",
        Headers = headers,
        Body = body
    })
    
    if response.StatusCode == 200 then
        print("Delete successful:", response.Body)
    else
        print("Request failed:", response.StatusCode, response.StatusMessage)
    end
end

-- Function to update currentmoneydrop field in the server
local function updateCurrentMoneyDrop(username, incrementAmount)
    local headers = {
        ["Content-Type"] = "application/json"
    }
    local data = {
        ["username"] = username,
        ["incrementAmount"] = incrementAmount
    }
    local body = httpService:JSONEncode(data)
    
    -- Debugging: Print the URL and request details
    print("Incrementing current money drop for user:", username)
    print("URL:", updateMoneyDropUrl)
    print("Request Body:", body)
    
    local success, response = pcall(function()
        return request({
            Url = updateMoneyDropUrl,
            Method = "POST",
            Headers = headers,
            Body = body
        })
    end)
    
    if success then
        if response.StatusCode == 200 then
            print("Increment currentmoneydrop successful:", response.Body)
        else
            print("Request failed with status code:", response.StatusCode)
            print("Response:", response.Body)
        end
    else
        print("Request failed with error:", response)
    end
end

-- Function to make MoneyDrop and its descendants invisible
local function makeMoneyDropInvisible(moneyDrop)
    if moneyDrop:IsA("BasePart") then
        moneyDrop.Transparency = 1
        moneyDrop.CanCollide = false
    end

    for _, descendant in pairs(moneyDrop:GetDescendants()) do
        if descendant:IsA("Decal") or descendant:IsA("Texture") then
            descendant.Transparency = 1
        elseif descendant:IsA("TextLabel") then
            descendant.Visible = false
        end
    end
end

-- Get the Drop folder from Workspace.Ignored
local dropFolder = workspace:WaitForChild("Ignored"):WaitForChild("Drop")

-- Iterate through all parts in the Drop folder and make MoneyDrop parts invisible
for _, item in pairs(dropFolder:GetChildren()) do
    if item.Name == "MoneyDrop" then
        makeMoneyDropInvisible(item)
    end
end

-- Function to calculate the number of drops needed per account
local function calculateDropsPerAccount(totalTargetAmount, numAccounts, dropAmount, netAmount)
    local taxRate = 1 - (netAmount / dropAmount)
    local grossAmountPerAccount = (totalTargetAmount / numAccounts) / (1 - taxRate)
    local dropsPerAccount = grossAmountPerAccount / dropAmount
    
    -- Round to the nearest whole number, rounding up if the decimal part is 0.2 or higher
    if dropsPerAccount % 1 >= 0.2 then
        dropsPerAccount = math.ceil(dropsPerAccount)
    else
        dropsPerAccount = math.floor(dropsPerAccount)
    end
    
    return dropsPerAccount
end

local function dropMoney(totalTargetAmount, numAccounts, targetUsername)
    -- Calculate the target amount per account
    local targetAmountPerAccount = totalTargetAmount / numAccounts
    local dropsPerAccount = calculateDropsPerAccount(targetAmountPerAccount, numAccounts, dropAmount, netAmount)
    local totalDropped = 0
    local totalDrops = dropsPerAccount * numAccounts
    
    for i = 1, totalDrops do
        -- Drop money
        MainEvent:FireServer("DropMoney", dropAmount)
        totalDropped = totalDropped + dropAmount
        
        print("Dropped", totalDropped, "money. Target per account is", targetAmountPerAccount)
        
        -- Update currentmoneydrop in the server
        updateCurrentMoneyDrop(targetUsername, totalDropped)
        
        -- Send a chat message after each drop
        sendChatMessage("Dropped " .. totalDropped .. " money. Target per account is " .. targetAmountPerAccount)
        
        -- Wait for the cooldown before the next drop
        wait(cooldown)
        
        -- Make all MoneyDrop parts invisible
        for _, item in pairs(dropFolder:GetChildren()) do
            if item.Name == "MoneyDrop" then
                makeMoneyDropInvisible(item)
            end
        end
        
        -- Reset the messageSent flag for the next drop
        messageSent = false
    end
    
    print("Reached target amount of", totalTargetAmount, "money.")
end

-- Function to start money dropping and send a chat message when the target user joins
local function onTargetUserJoined(player, targetUsername, totalTargetAmount)
    print("Checking if player is target user:", player.Name, targetUsername)
    if player.Name == targetUsername or player.DisplayName == targetUsername then
        print("Target user joined. Starting money drop...")
        
        -- Send a chat message
        sendChatMessage("User has joined: starting dropping order amount: " .. totalTargetAmount)

        dropMoney(totalTargetAmount, #altAccountUserIds + 1, targetUsername)
        
        -- Delete user data after dropping money
        deleteUser(targetUsername)
    end
end

-- Function to teleport the player to a specific CFrame
local function teleportPlayer(player, cframe)
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    
    humanoidRootPart.CFrame = cframe
end

-- Function to set up event listeners for each target user
local function setupEventListeners(data)
    for _, entry in ipairs(data) do
        local targetUsername = entry.username
        local totalTargetAmount = convertAmount(entry.amount)
        print("Setting up listener for user:", targetUsername, "with amount:", totalTargetAmount)
        
        -- Listen for players joining and check if they are the target user
        game.Players.PlayerAdded:Connect(function(player)
            print("Player joined:", player.Name)
            onTargetUserJoined(player, targetUsername, totalTargetAmount)
        end)
    end
end

-- Function to make all parts in the workspace invisible
local function makeWorkspaceInvisible()
    for _, descendant in pairs(workspace:GetDescendants()) do
        if descendant:IsA("BasePart") then
            descendant.Transparency = 1
            descendant.CanCollide = false
        elseif descendant:IsA("Decal") or descendant:IsA("Texture") then
            descendant.Transparency = 1
        elseif descendant:IsA("TextLabel") then
            descendant.Visible = false
        end
    end
end

-- Function to create a floating platform at a specified CFrame
local function createFloatingPlatformAtCFrame(cframePosition)
    -- Create the platform part
    local platform = Instance.new("Part")
    platform.Size = Vector3.new(400, 1, 40)  -- Adjust size as needed
    platform.Anchored = true
    platform.CanCollide = true
    platform.Transparency = 0.5  -- Adjust transparency as needed
    platform.BrickColor = BrickColor.new("Bright blue")  -- Adjust color as needed
    platform.Name = "FloatingPlatform"
    

    -- Position the platform at the specified CFrame
    platform.CFrame = cframePosition

    -- Parent the platform to the workspace
    platform.Parent = workspace
end

-- Example CFrame position, adjust as needed
local cframePosition = CFrame.new(-375, 12, -350.124939, 0, 0, 1, 0, 1, -0, -1, 0, 0)

-- Make the workspace invisible
makeWorkspaceInvisible()

-- Create the floating platform immediately when the script is executed
createFloatingPlatformAtCFrame(cframePosition)

-- Teleport the main account and alt accounts
local player = game.Players.LocalPlayer
teleportPlayer(player, baseCFrame)
sendChatMessage("Successfully setup, waiting for orders.")

for i, userId in ipairs(altAccountUserIds) do
    local altPlayer = game.Players:GetPlayerByUserId(userId)
    if altPlayer then
        local altCFrame = baseCFrame + offset * i
        teleportPlayer(altPlayer, altCFrame)
        sendChatMessage("Alt account " .. i .. " successfully setup, waiting for orders.")
    end
end

-- Keep fetching data every 5 seconds to check for new buyers
while true do
    local data = fetchData()
    print("Fetched data:", data)
    setupEventListeners(data)
    wait(5)  -- Fetch data every 5 seconds
end
