getgenv().alts = { 
    7516826290,
    7516830917,
    7516836003,
    7516838927,
    7516841987,
    7516918660,
    7516921961,
    7516924357,
    7516927773,
    7516929512,
    7516942064,
    7516946194,
    7516957691,
    7516962411,
    7516964847,
    7516968092,
    7516982216,
    7516986808,
    7516993038,
    7516996805,
    7516998777,
    7517001782,
    7517002641,
    7517008580,
    7517011809,
    7517012189,
    7517015792
}
getgenv().dont_kick = { --dont server kick at end of drop
    3311210222,
    337641113,
    2682673712,
    7228189221,

}
local ps_owner_id = 7516826290

local shoutMessage = "Kindly take a wallet-screenshot with our bots and vouch in the #vouches channel."
local shoutMessage2 = "Thank you for being a valued customer."
local kickdelay = 300
local client_id = "config"

local ws = WebSocket.connect("ws://192.168.1.6:8080")


local Workspace = game:GetService('Workspace')
local Lighting = game:GetService('Lighting')
local Players = game:GetService('Players')
local Terrain = Workspace:FindFirstChild('Terrain')
local RunService = game:GetService("RunService")
local request = http_request or request or HttpPost or syn.request
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local GroupService = game:GetService("GroupService")
local Stats = game:GetService("Stats")
local Lighting = game:GetService("Lighting")
local replicatedStorage = game:GetService("ReplicatedStorage")
local mainEvent = replicatedStorage:WaitForChild("MainEvent")
local players = game:GetService("Players")
local localPlayer = players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local Workspace = game:GetService('Workspace')



--Consts
local PLAYER = Players.LocalPlayer
local DATA_FOLDER = PLAYER:WaitForChild("DataFolder")
local INVENTORY = DATA_FOLDER:WaitForChild("Inventory")
local PLAYER_CASH = DATA_FOLDER:WaitForChild("Currency")
local INFORMATION = DATA_FOLDER:WaitForChild("Information")
local ORIGINAL_CASH_AMOUNT = PLAYER_CASH.Value
local IGNORED = workspace:WaitForChild("Ignored")
local ATMS = workspace:WaitForChild("Cashiers")
local PLAYERS_FOLDER = workspace:WaitForChild("Players")
local SHOP = IGNORED:WaitForChild("Shop")
local ITEMS_DROP = IGNORED:WaitForChild("ItemsDrop")
local CASH_DROP = IGNORED:WaitForChild("Drop")
local SHOPS = SHOP:GetChildren()
local SPAWN = IGNORED:WaitForChild("Spawn")
local LIGHTS = workspace:WaitForChild("Lights")
local MAIN_EVENT = ReplicatedStorage:WaitForChild("MainEvent")
local PLAYER_CASH = PLAYER.DataFolder:WaitForChild("Currency")
local ORIGINAL_CASH_AMOUNT = PLAYER_CASH.Value
local REQUIRED_ITEMS = {
	["[Knife] - $159"] = 2,
	["[Revolver] - $1379"] = 1,
	["12 [Revolver Ammo] - $80"] = 1,
	["[Key] - $133"] = 1,
}
local REQUIRED_CHAR_PARTS = {
    ["Humanoid"] = true,
    ["HumanoidRootPart"] = true,
    ["UpperTorso"] = true,
    ["LowerTorso"] = true,
    ["Head"] = true,
}

local replicatedStorage = game:GetService("ReplicatedStorage")
local mainEvent = replicatedStorage:WaitForChild("MainEvent")
local players = game:GetService("Players")
local localPlayer = players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local Workspace = game:GetService('Workspace')

local teleportPositions = {
    { -393.01, 36, -338 },
    { -381.01, 36, -338 },
    { -369.01, 36, -338 },
    { -357.01, 36, -338 },
    { -393.01, 36, -325 },
    { -381.01, 36, -325 },
    { -369.01, 36, -325 },
    { -357.01, 36, -325 },
    { -393.01, 36, -312 },
    { -381.01, 36, -312 },
    { -369.01, 36, -312 },
    { -357.01, 36, -312 },
    { -393.01, 36, -299 },
    { -381.01, 36, -299 },
    { -369.01, 36, -299 },
    { -357.01, 36, -299 },
    { -393.01, 36, -286 },
    { -381.01, 36, -286 },
    { -369.01, 36, -286 },
    { -357.01, 36, -286 },
    { -393.01, 36, -273 },
    { -381.01, 36, -273 },
    { -369.01, 36, -273 },
    { -357.01, 36, -273 },
    { -393.01, 36, -260 },
    { -381.01, 36, -260 },
    { -369.01, 36, -260 },
    { -357.01, 36, -260 },
    { -393.01, 36, -247 },
    { -381.01, 36, -247 },
    { -369.01, 36, -247 },
    { -357.01, 36, -247 },
    { -393.01, 36, -233 },
    { -381.01, 36, -233 },
    { -369.01, 36, -233 },
    { -357.01, 36, -233 },
    { -405.01, 36, -299 },
    { -405.01, 36, -286 },
    { -405.01, 36, -273 },
}

function getAltNumber(userId)
    local alts = getgenv().alts
    for i, id in ipairs(alts) do
        if userId == id then
            return i
        end
    end
    return false
end





local TweenService = game:GetService("TweenService")



    
local function teleport(position)
    local position = CFrame.new(position[1], position[2], position[3])
    task.spawn(function()
        while task.wait() do
            pcall(function()
                localPlayer.Character:WaitForChild("HumanoidRootPart").CFrame = position
                localPlayer.Character:WaitForChild("HumanoidRootPart").Velocity = Vector3.new(0, 0, 0)
            end)
        end
    end)
end

function teleportBasedOnAltNumber(player)
    local userId = player.UserId
    local altNumber = getAltNumber(userId)
    local position = teleportPositions[altNumber] or { -381.01, 35.75, -286 }

    teleport(position)
end




function ismacro() 
    return game:GetService("Lighting"):GetAttribute("MacroAllow") or false 
end 



if game.Players.LocalPlayer.UserId == ps_owner_id then
    if ismacro() then
        print("Macro is already on")
    else
        game:GetService("ReplicatedStorage"):WaitForChild("MainEvent"):FireServer("RoleplayModeChange")
        wait(1)
        game:GetService("ReplicatedStorage"):WaitForChild("MainEvent"):FireServer("MacroModeChange")
    end
else
    if ismacro() then
        print("Macro is already on")
    else
        wait(30)  -- You might want to handle this differently if needed
    end    
end



teleportBasedOnAltNumber(localPlayer)



Terrain.WaterWaveSize = 0
Terrain.WaterWaveSpeed = 0
Terrain.WaterReflectance = 0
Terrain.WaterTransparency = 0
Lighting.GlobalShadows = false
Lighting.FogEnd = 9e9
Lighting.Brightness = 0

for _, v in ipairs(game:GetDescendants()) do
    if v:IsA("Part") or v:IsA("Union") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
        v.Material = "Plastic"
        v.Reflectance = 0
    elseif v:IsA("Decal") or v:IsA("Texture") and v.Parent.Name ~= "Spill" then
        v.Parent = game:GetService('Workspace').Terrain
        v:remove()
    elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
        v.Parent = game:GetService('Workspace').Terrain
        v:remove()
    elseif v:IsA("Explosion") then
        v.Parent = game:GetService('Workspace').Terrain
        v:remove()
    elseif v:IsA("Fire") or v:IsA("SpotLight") or v:IsA("Smoke") then
        v.Parent = game:GetService('Workspace').Terrain
        v:remove()
    elseif v:IsA("MeshPart") then
        v.Material = "Plastic"
        v.Reflectance = 0
        v.TextureID = 0
        v.MeshId = 'rbxassetid://0'
    elseif v:IsA('Model') then
        sethiddenproperty(v, "LevelOfDetail", "Automatic")
    end
end

local decalsyeeted = true
local g = game
local w = g.Workspace
local l = g.Lighting
local t = w.Terrain
t.WaterWaveSize = 0
t.WaterWaveSpeed = 0
t.WaterReflectance = 0
t.WaterTransparency = 0
l.GlobalShadows = false
l.FogEnd = 9e9
l.Brightness = 0
settings().Rendering.QualityLevel = "Level01"
for i, v in ipairs(g:GetDescendants()) do
    if v:IsA("Part") or v:IsA("Union") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
        v.Material = "Plastic"
        v.Reflectance = 0
    elseif v:IsA("Decal") or v:IsA("Texture") and decalsyeeted then
        v.Transparency = 1
    elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
        v.Lifetime = NumberRange.new(0)
    elseif v:IsA("Explosion") then
        v.BlastPressure = 1
        v.BlastRadius = 1
    elseif v:IsA("Fire") or v:IsA("SpotLight") or v:IsA("Smoke") then
        v.Enabled = false
    elseif v:IsA("MeshPart") then
        v.Material = "Plastic"
        v.Reflectance = 0
        v.TextureID = 10385902758728957
    end
end
for i, e in ipairs(l:GetChildren()) do
    if e:IsA("BlurEffect") or e:IsA("SunRaysEffect") or e:IsA("ColorCorrectionEffect") or e:IsA("BloomEffect") or e:IsA("DepthOfFieldEffect") then
        e:remove()
    else
        e:remove()
    end
end
for _,v in ipairs(game:GetService("Workspace"):GetDescendants()) do
    if v:IsA('Seat') or string.lower(v.Name):match('seat') then v:remove() end -- removes all seating in the game (prevents bugs)
end


local player_1234_id = game.Players.LocalPlayer.UserId
function getAltNumber2(userId)
    local alts = getgenv().alts
    for i, id in ipairs(alts) do
        if userId == id then
            return i
        end
    end
    return false
end

local result = getAltNumber2(player_1234_id)
    -- Check if the result is 1 and print "true" if it is
if result == 1 then
    local function makeEverythingInvisible()
        -- Get all parts in the workspace
        local allParts = game.Workspace:GetDescendants()

        -- Iterate through all parts and make them invisible
        for _, part in ipairs(allParts) do
            if part:IsA("BasePart") then
                part.Transparency = 1
            end
        end
    end

    makeEverythingInvisible()










    local lastReceivedMessage = ""  -- Variable to store the last received message
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local StarterGui = game:GetService("StarterGui")
    local GroupService = game:GetService("GroupService")
    local Lighting = game:GetService("Lighting")
    local TweenService = game:GetService("TweenService")
    local Stats = game:GetService("Stats")
    local ChatService = game:GetService("Chat")
    local PLAYER = Players.LocalPlayer
    local DATA_FOLDER = PLAYER:WaitForChild("DataFolder")
    local INFORMATION = DATA_FOLDER:WaitForChild("Information")
    local INVENTORY = DATA_FOLDER:WaitForChild("Inventory")
    local PLAYER_CREW = INFORMATION:FindFirstChild("Crew")
    local PLAYER_CASH = PLAYER.DataFolder:WaitForChild("Currency")
    local ORIGINAL_CASH_AMOUNT = PLAYER_CASH.Value
    local REQUIRED_CHAR_PARTS = {
        ["Humanoid"] = true,
        ["HumanoidRootPart"] = true,
        ["UpperTorso"] = true,
        ["LowerTorso"] = true,
        ["Head"] = true,
    }
    local CASHIERS = workspace:WaitForChild("Cashiers")
    local IGNORED = workspace:WaitForChild("Ignored")
    local PLAYERS_FOLDER = workspace:WaitForChild("Players")
    local ITEMS_DROP = IGNORED:WaitForChild("ItemsDrop")
    local SHOP = IGNORED:WaitForChild("Shop")
    local SHOPS = SHOP:GetChildren()
    local SPAWN = IGNORED:WaitForChild("Spawn")
    local LIGHTS = workspace:WaitForChild("Lights")
    local MAP = workspace:WaitForChild("MAP")
    local LOW_GFX_PARTS = {} -- [part] = originalMaterial
    local MAIN_EVENT = ReplicatedStorage:WaitForChild("MainEvent")
    local CHAT_EVENT = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("SayMessageRequest")
    local PLAYER_GUI = PLAYER:WaitForChild("PlayerGui")
    local CORE_GUI = game.CoreGui



    -- Assuming PLAYER is defined and is the current player
    local PLAYER = game.Players.LocalPlayer

    -- Create LowGfxScreenGui (of 'ScreenGui' class) if it doesn't exist
    if CORE_GUI then
        local LowGfxScreenGui = CORE_GUI:FindFirstChild("LowGfxScreenGui")
        if not LowGfxScreenGui then
            LowGfxScreenGui = Instance.new("ScreenGui")
            LowGfxScreenGui.Name = "LowGfxScreenGui"
            LowGfxScreenGui.Enabled = true -- Set to true by default
            LowGfxScreenGui.IgnoreGuiInset = true
            LowGfxScreenGui.Parent = CORE_GUI

            -- Create LowGfxBackground Frame
            local LowGfxBackground = Instance.new("Frame")
            LowGfxBackground.Name = "LowGfxBackground"
            LowGfxBackground.BorderColor3 = Color3.new(0.105882, 0.164706, 0.207843)
            LowGfxBackground.BackgroundColor3 = Color3.new(0, 0, 0) -- Set background color to black
            LowGfxBackground.Size = UDim2.new(1, 0, 1, 0)
            LowGfxBackground.Parent = LowGfxScreenGui

            -- Create LGFXUIGradient UIGradient
            local LGFXUIGradient = Instance.new("UIGradient")
            LGFXUIGradient.Name = "LGFXUIGradient"
            LGFXUIGradient.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)),
                ColorSequenceKeypoint.new(1, Color3.new(0.176471, 0.176471, 0.176471))
            }
            LGFXUIGradient.Rotation = 290
            LGFXUIGradient.Parent = LowGfxBackground

            -- Create LowGfxTitle TextLabel
            local LowGfxTitle = Instance.new("TextLabel")
            LowGfxTitle.Name = "LowGfxTitle"
            LowGfxTitle.Text = tostring(PLAYER_CASH.Value) -- Initialize with current cash value
            LowGfxTitle.TextColor3 = Color3.new(1, 1, 1) -- White text color
            LowGfxTitle.BackgroundTransparency = 1 -- No background
            LowGfxTitle.Size = UDim2.new(0.2, 0, 0.1, 0) -- Adjust size as needed
            LowGfxTitle.Position = UDim2.new(0.4, 0, 0.05, 0) -- Centered horizontally, adjust vertically as needed
            LowGfxTitle.Font = Enum.Font.SourceSans
            LowGfxTitle.TextScaled = true
            LowGfxTitle.Parent = LowGfxBackground

            -- Connect the function to update the cash text when it changes
            PLAYER_CASH.Changed:Connect(function()
                if LowGfxTitle then
                    LowGfxTitle.Text = tostring(PLAYER_CASH.Value)
                else
                    print("LowGfxTitle not found")
                end
            end)

            -- Create Username TextLabel
            local UsernameLabel = Instance.new("TextLabel")
            UsernameLabel.Name = "UsernameLabel"
            UsernameLabel.Text = PLAYER.Name -- Set to player's username
            UsernameLabel.TextColor3 = Color3.new(1, 1, 1) -- White text color
            UsernameLabel.BackgroundTransparency = 1 -- No background
            UsernameLabel.Size = UDim2.new(0.3, 0, 0.05, 0) -- Adjust size as needed
            UsernameLabel.Position = UDim2.new(0.35, 0, 0.12, 0) -- Centered horizontally below the cash label
            UsernameLabel.Font = Enum.Font.SourceSans
            UsernameLabel.TextScaled = true
            UsernameLabel.Parent = LowGfxBackground

            -- Create ProfilePicture ImageLabel
            local ProfilePicture = Instance.new("ImageLabel")
            ProfilePicture.Name = "ProfilePicture"
            ProfilePicture.Size = UDim2.new(0.1, 0, 0.1, 0) -- Adjust size as needed
            ProfilePicture.Position = UDim2.new(0.45, 0, 0.01, 0) -- Adjust position as needed
            ProfilePicture.BackgroundTransparency = 1 -- No background
            ProfilePicture.Image = "http://www.roblox.com/Thumbs/Avatar.ashx?x=100&y=100&Format=png&userId="..PLAYER.UserId -- Get the player's avatar
            ProfilePicture.Parent = LowGfxBackground
        end

        print("LowGfxScreenGui created and enabled")
    else
        print("CORE_GUI not found")
    end




    local function findPlayer(name)
        if name then
            --If they typed the name exactly, then return that
            if Players:FindFirstChild(name) then return Players[name] end

            --Otherwise search for player name match
            name = name:lower()

            for _, player in ipairs(Players:GetPlayers()) do
                if name == player.Name:lower():sub(1, #name) then
                    return player
                end
            end
        end
        return nil
    end


    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    
    -- Function to handle when a new player joins
    local function onPlayerAdded(player)
        print("Player joined:", player.Name)
        print("Welcome to the game!")
        wait(10)
        -- Execute provided code for the joined player
        local ohString1 = "VIP_CMD"
        local ohString2 = "Summon"
        local ohInstance3 = player
    
        ReplicatedStorage.MainEvent:FireServer(ohString1, ohString2, ohInstance3)
    
    end
    
    Players.PlayerAdded:Connect(onPlayerAdded)

    -- Assuming PLAYER is defined and is the current player
    local PLAYER = game.Players.LocalPlayer

    -- Create LowGfxScreenGui (of 'ScreenGui' class) if it doesn't exist
    if CORE_GUI then
        local LowGfxScreenGui = CORE_GUI:FindFirstChild("LowGfxScreenGui")
        if not LowGfxScreenGui then
            LowGfxScreenGui = Instance.new("ScreenGui")
            LowGfxScreenGui.Name = "LowGfxScreenGui"
            LowGfxScreenGui.Enabled = true -- Set to true by default
            LowGfxScreenGui.IgnoreGuiInset = true
            LowGfxScreenGui.Parent = CORE_GUI

            -- Create LowGfxBackground Frame
            local LowGfxBackground = Instance.new("Frame")
            LowGfxBackground.Name = "LowGfxBackground"
            LowGfxBackground.BorderColor3 = Color3.new(0.105882, 0.164706, 0.207843)
            LowGfxBackground.BackgroundColor3 = Color3.new(0, 0, 0) -- Set background color to black
            LowGfxBackground.Size = UDim2.new(1, 0, 1, 0)
            LowGfxBackground.Parent = LowGfxScreenGui

            -- Create LGFXUIGradient UIGradient
            local LGFXUIGradient = Instance.new("UIGradient")
            LGFXUIGradient.Name = "LGFXUIGradient"
            LGFXUIGradient.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)),
                ColorSequenceKeypoint.new(1, Color3.new(0.176471, 0.176471, 0.176471))
            }
            LGFXUIGradient.Rotation = 290
            LGFXUIGradient.Parent = LowGfxBackground

            -- Create LowGfxTitle TextLabel
            local LowGfxTitle = Instance.new("TextLabel")
            LowGfxTitle.Name = "LowGfxTitle"
            LowGfxTitle.Text = tostring(PLAYER_CASH.Value) -- Initialize with current cash value
            LowGfxTitle.TextColor3 = Color3.new(1, 1, 1) -- White text color
            LowGfxTitle.BackgroundTransparency = 1 -- No background
            LowGfxTitle.Size = UDim2.new(0.2, 0, 0.1, 0) -- Adjust size as needed
            LowGfxTitle.Position = UDim2.new(0.4, 0, 0.05, 0) -- Centered horizontally, adjust vertically as needed
            LowGfxTitle.Font = Enum.Font.SourceSans
            LowGfxTitle.TextScaled = true
            LowGfxTitle.Parent = LowGfxBackground

            -- Connect the function to update the cash text when it changes
            PLAYER_CASH.Changed:Connect(function()
                if LowGfxTitle then
                    LowGfxTitle.Text = tostring(PLAYER_CASH.Value)
                else
                    print("LowGfxTitle not found")
                end
            end)

            -- Create Username TextLabel
            local UsernameLabel = Instance.new("TextLabel")
            UsernameLabel.Name = "UsernameLabel"
            UsernameLabel.Text = PLAYER.Name -- Set to player's username
            UsernameLabel.TextColor3 = Color3.new(1, 1, 1) -- White text color
            UsernameLabel.BackgroundTransparency = 1 -- No background
            UsernameLabel.Size = UDim2.new(0.3, 0, 0.05, 0) -- Adjust size as needed
            UsernameLabel.Position = UDim2.new(0.35, 0, 0.12, 0) -- Centered horizontally below the cash label
            UsernameLabel.Font = Enum.Font.SourceSans
            UsernameLabel.TextScaled = true
            UsernameLabel.Parent = LowGfxBackground

            -- Create ProfilePicture ImageLabel
            local ProfilePicture = Instance.new("ImageLabel")
            ProfilePicture.Name = "ProfilePicture"
            ProfilePicture.Size = UDim2.new(0.1, 0, 0.1, 0) -- Adjust size as needed
            ProfilePicture.Position = UDim2.new(0.45, 0, 0.01, 0) -- Adjust position as needed
            ProfilePicture.BackgroundTransparency = 1 -- No background
            ProfilePicture.Image = "http://www.roblox.com/Thumbs/Avatar.ashx?x=100&y=100&Format=png&userId="..PLAYER.UserId -- Get the player's avatar
            ProfilePicture.Parent = LowGfxBackground
        end

        print("LowGfxScreenGui created and enabled")
    else
        print("CORE_GUI not found")
    end




    local function makeEverythingInvisible()
        -- Get all parts in the workspace
        local allParts = game.Workspace:GetDescendants()

        -- Iterate through all parts and make them invisible
        for _, part in ipairs(allParts) do
            if part:IsA("BasePart") then
                part.Transparency = 1
            end
        end
    end

    makeEverythingInvisible()



    local count = 0
    for _, v in ipairs(game:GetDescendants()) do
        if v:IsA("Decal") and v.Name ~= "face" then
            v:Destroy()
        end
        if count < 1200 then
            count += 1
        else
            count = 0
            task.wait()
        end
    end
                    
        
    for part, originalMaterial in pairs(LOW_GFX_PARTS) do
        part.Material = Enum.Material.SmoothPlastic
        if count < 1200 then
            count += 1
        else
            count = 0
            task.wait()
        end
    end




    



    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
     
    local PLAYER = Players.LocalPlayer
    

    local function isProtectedPlayer(userId)
        for _, id in ipairs(getgenv().alts) do
            if userId == id then
                return true
            end
        end
        for _, id in ipairs(getgenv().dont_kick) do
            if userId == id then
                return true
            end
        end
        return false
    end

    local function kickAllUnprotectedPlayers()
        print("trying to kick players")
        for _, player in ipairs(Players:GetPlayers()) do
            -- Check if the player is protected
            if not isProtectedPlayer(player.UserId) then
                -- Fire the server event to kick the player
                ReplicatedStorage.MainEvent:FireServer("VIP_CMD", "Kick", player)
            end
        end
    end

    -- Define currency postfixes and max duration
    local currencyPostFixes = {
        ["k"] = 1000,
        ["m"] = 1000000,
        ["b"] = 1000000000,
    }
    local MAX_DURATION = 30

    -- Function to handle kicking players with VIP_CMD
    local function vipKick(player)
        if player.Parent and not isProtectedPlayer(player.UserId) then
            ReplicatedStorage.MainEvent:FireServer("VIP_CMD", "Kick", player)
        end
    end


    -- Function to kick a player by their name
    local function Kick(playerName)
        if not playerName or playerName == "" then
            print("Error: Player name is required.")
            return
        end

        -- Find the player by name
        local player = game:GetService("Players"):FindFirstChild(playerName)
        
        if player then
            -- Define the command arguments
            local args = {
                [1] = "VIP_CMD",  -- Command type or identifier
                [2] = "Kick",     -- Action to perform
                [3] = player      -- The player object to be kicked
            }

            -- Fire the event with the defined arguments
            game:GetService("ReplicatedStorage").MainEvent:FireServer(unpack(args))
            print("Kick command sent for player:", playerName)
        else
            print("Error: Player not found.")
        end
    end

    -- Function to handle kicking players with VIP_CMD
    local function shout(message)
        game:GetService("ReplicatedStorage"):WaitForChild("MainEvent"):FireServer("Shout", message)
    end



    -- Shared flag to control stopping the dropping process
    local stopDropping = false

    local is_dropping = false

    -- Function to set the stop flag
    function stopDropProcess()
        if is_dropping == true then
            is_dropping = false
            stopDropping = true
        end
    end

    -- Function to reset the stop flag
    function resetDropProcess()
        stopDropping = false
    end

    -- Modified dropMoney function
    function dropMoney(money, name)
        is_dropping = true
        local amountString = money
        local limit = tonumber(amountString)
        
        if not limit then
            for postFix, value in pairs(currencyPostFixes) do
                if string.find(amountString, postFix) then
                    local rawNumberString = string.gsub(amountString, postFix, "")
                    local amountNumber = tonumber(rawNumberString)
                    limit = amountNumber * value
                    break
                end
            end
        end
        
        if limit then
            local numberOfAltsInGame = countAltsInGame() -- Number of alts in the game
            local targetdrop = limit / numberOfAltsInGame -- Amount per alt
            local roundedTimestoDrop = math.ceil(targetdrop / 12750) -- Time to drop
            CHAT_EVENT:FireServer("Started dropping " .. tostring(money) .. ", for " .. tostring(name), "All")
            
            local currentValue = 0 
            for i = 1, roundedTimestoDrop do
                if stopDropping then
                    print("Stopped dropping")
                    CHAT_EVENT:FireServer("Stopped Dropping", "All")
                    resetDropProcess()  -- Reset the flag before returning
                    local finished_M = string.format("%s %s", client_id, "FINISHED-DROP")
                    print("Sending message:", finished_M)
                    local success2, err = pcall(function()
                        ws:Send(finished_M)
                    end)
                    
                    if not success2 then
                        print("Failed to send WebSocket message:", err)
                        return
                    end
                    return
                end

                currentValue = currentValue + 8500
                final_amount_alts = currentValue * numberOfAltsInGame
                local message = string.format("%s %s %s %s %s", client_id, "DROPPING-STATUS", tostring(final_amount_alts), tostring(numberOfAltsInGame), tostring(limit))
                print("Sending message:", message)
                local success, err = pcall(function()
                    ws:Send(message)
                end)
                
                if not success then
                    print("Failed to send WebSocket message:", err)
                    resetDropProcess()  -- Reset the flag in case of an error
                    return
                end

                MAIN_EVENT:FireServer("DropMoney", 15000)  -- Fire the server event with a payload of 10000
                
                -- Check the flag frequently even if it's not at the start
                if stopDropping then
                    print("Stopped dropping")
                    CHAT_EVENT:FireServer("Stopped Dropping", "All")
                    resetDropProcess()  -- Reset the flag before returning
                    local finished_M = string.format("%s %s", client_id, "FINISHED-DROP")
                    print("Sending message:", finished_M)
                    local success2, err = pcall(function()
                        ws:Send(finished_M)
                    end)
                    
                    if not success2 then
                        print("Failed to send WebSocket message:", err)
                        return
                    end
                    return
                end
                
                wait(16.5)  
            end
            CHAT_EVENT:FireServer("Finshed dropping " .. tostring(money) .. ", for " .. tostring(name), "All")
            -- Continue with remaining logic
            if stopDropping then
                print("Stopped dropping")
                CHAT_EVENT:FireServer("Stopped Dropping", "All")
                resetDropProcess()  -- Reset the flag before returning
                local finished_M = string.format("%s %s", client_id, "FINISHED-DROP")
                print("Sending message:", finished_M)
                local success2, err = pcall(function()
                    ws:Send(finished_M)
                end)
                
                if not success2 then
                    print("Failed to send WebSocket message:", err)
                    return
                end
                return
            end
            
            
            wait(5)
            for _ = 1, 6 do
                if stopDropping then
                    print("Stopped dropping")
                    CHAT_EVENT:FireServer("Stopped Dropping", "All")
                    resetDropProcess()  -- Reset the flag before returning
                    local finished_M = string.format("%s %s", client_id, "FINISHED-DROP")
                    print("Sending message:", finished_M)
                    local success2, err = pcall(function()
                        ws:Send(finished_M)
                    end)
                    
                    if not success2 then
                        print("Failed to send WebSocket message:", err)
                        return
                    end
                    return
                end
                game:GetService("ReplicatedStorage"):WaitForChild("MainEvent"):FireServer("Shout", shoutMessage)
                wait(5)
            end
            
            if stopDropping then
                print("Stopped dropping")
                CHAT_EVENT:FireServer("Stopped Dropping", "All")
                resetDropProcess()  -- Reset the flag before returning
                local finished_M = string.format("%s %s", client_id, "FINISHED-DROP")
                print("Sending message:", finished_M)
                local success2, err = pcall(function()
                    ws:Send(finished_M)
                end)
                
                if not success2 then
                    print("Failed to send WebSocket message:", err)
                    return
                end
                return
            end
            
            local delaytimer = kickdelay / 4
            for i = 4, 1, -1 do
                if stopDropping then
                    print("Stopped dropping")
                    CHAT_EVENT:FireServer("Stopped Dropping", "All")
                    resetDropProcess()  -- Reset the flag before returning
                    local finished_M = string.format("%s %s", client_id, "FINISHED-DROP")
                    print("Sending message:", finished_M)
                    local success2, err = pcall(function()
                        ws:Send(finished_M)
                    end)
                    
                    if not success2 then
                        print("Failed to send WebSocket message:", err)
                        return
                    end
                    return
                end
                
                -- Calculate remaining time before sending the warning
                local remainingTime = delaytimer * i
                ReplicatedStorage:WaitForChild("MainEvent"):FireServer("Shout", "You will be kicked from the server in " .. tostring(remainingTime) .. " seconds.")
                
                -- Wait for the appropriate delay
                wait(delaytimer)
            end
            
            
            if stopDropping then
                print("Stopped dropping")
                CHAT_EVENT:FireServer("Stopped Dropping", "All")
                resetDropProcess()  -- Reset the flag before returning
                local finished_M = string.format("%s %s", client_id, "FINISHED-DROP")
                print("Sending message:", finished_M)
                local success2, err = pcall(function()
                    ws:Send(finished_M)
                end)
                
                if not success2 then
                    print("Failed to send WebSocket message:", err)
                    return
                end
                return
            end
            

            local finished_M = string.format("%s %s", client_id, "FINISHED-DROP")
            print("Sending message:", finished_M)
            local success2, err = pcall(function()
                ws:Send(finished_M)
            end)
            
            if not success2 then
                print("Failed to send WebSocket message:", err)
                resetDropProcess()
                return
            end



            kickAllUnprotectedPlayers()
            print("Finished drop at very very end")
            
            is_dropping = false
            resetDropProcess()
        end
    end

    




    function countAltsInGame()
        local alts = getgenv().alts
        local count = 0

        -- Iterate through the list of alt IDs
        for _, altID in ipairs(alts) do
            -- Check if the player with the alt ID is in the game
            local player = game.Players:GetPlayerByUserId(altID)
            if player then
                -- If player is found, increment the count
                count = count + 1
            end
        end

        -- Return the count of alts in the game
        return count
    end






    -- Function to check if a player is an alt
    local function isAlt(player)
        return table.find(alts, player.UserId)
    end

    -- Function to calculate and return the combined cash value of alts in the game
    local function getCombinedCashOfAltsInGame()
        local totalCash = ORIGINAL_CASH_AMOUNT
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= PLAYER and isAlt(player) then
            totalCash = totalCash + player:WaitForChild("DataFolder"):WaitForChild("Currency").Value
            end
        end
        return totalCash
    end

    

    -- Function to format numbers with commas and a dollar sign
    local function format_currency(value)
        local formatted = tostring(value)
        -- Add commas to the number
        formatted = formatted:reverse():gsub("%d%d%d", "%1,", formatted):reverse()
        -- Remove any leading comma (if the number is less than 1,000)
        formatted = formatted:gsub("^,", "")
        -- Add a dollar sign in front
        return "$" .. formatted
    end

    -- Function to print the server status with player details in one line
    local function print_server_status()
        local result = ""

        -- Add client_id and server status
        result = result .. client_id .. " SERVER-STATUS "
        result = result .. "Total Number of Players: " .. #Players:GetPlayers() .. " | "

        -- Add player info
        for _, player in ipairs(Players:GetPlayers()) do
            local dataFolder = player:FindFirstChild("DataFolder")
            if dataFolder then
                local currency = dataFolder:FindFirstChild("Currency")
                local formattedCurrency = currency and format_currency(currency.Value) or "Currency not found"
                result = result .. player.Name .. ": " .. formattedCurrency .. " | "
            else
                result = result .. player.Name .. ": DataFolder not found | "
            end
        end

        -- Remove the trailing " | " and print the result
        result = result:sub(1, -4)
        ws:Send(result)
    end


 
    local GC = getconnections or get_signal_cons
        if GC then
            for i,v in pairs(GC(Players.LocalPlayer.Idled)) do
                if v["Disable"] then
                    v["Disable"](v)
                elseif v["Disconnect"] then
                    v["Disconnect"](v)
                end
            end
        end
    print("Ran")




    IGNORED.Drop.ChildAdded:Connect(function(child)
        if child:IsA("Part") then
            task.wait(5)
            child.Transparency = 1
            child:WaitForChild("Decal"):Destroy()
            child:WaitForChild("Decal"):Destroy()
            child:WaitForChild("BillboardGui").Enabled = false
            child:Destroy()
        end
    end)

    --Hide cash
    IGNORED.Drop.ChildAdded:Connect(function(v)
        if hideCash == true and v:IsA("Part") and v.Parent ~= nil then
            v:WaitForChild("Decal"):Destroy()
            v:WaitForChild("Decal"):Destroy()
            v.Transparency = 1
            v:WaitForChild("BillboardGui").Enabled = false
        else
            v:WaitForChild("Decal"):Destroy()
            v:WaitForChild("Decal"):Destroy()
        end
    end)


    function getAltNumber(userId)
        local alts = getgenv().alts
        for i, id in ipairs(alts) do
            if userId == id then
                return i
            end
        end
        return false
    end

    
    


    

    settings().Rendering.QualityLevel = 1
    UserSettings().GameSettings.MasterVolume = 0
    RunService:Set3dRenderingEnabled(false)


  
    ws:Send(client_id)

    -- Define your WebSocket message handler
    ws.OnMessage:Connect(function(message)
        print("Message received:", message)
        local parts = {}
        
        -- Split the message by spaces and store the parts in the table
        for word in string.gmatch(message, "%S+") do
            table.insert(parts, word)
        end
        
        if parts[1] == "drop" then
            if #parts > 2 then
                local money = parts[2]  -- Get the second part of the message
                local name = parts[3]   -- Get the third part of the message
                
                -- Run the drop command in a coroutine
                local co = coroutine.create(function()
                    print("Drop command received")
                    dropMoney(money, name)
                end)
                coroutine.resume(co)
            else
                print("Invalid drop command format")
            end
        elseif parts[1] == "stop" then
            -- Run the stop command in a coroutine
            local co = coroutine.create(function()
                print("Running stop command")
                stopDropProcess()
            end)
            coroutine.resume(co)
        elseif parts[1] == "kick" then
            local player = parts[2]
            local co = coroutine.create(function()
                print("Running kick player command")
                Kick(player)
            end)
            coroutine.resume(co)
        elseif parts[1] == "shout" then
            local startIndex = 2
            local endIndex = #parts - 1
            local messageParts = {}
    
            for i = startIndex, endIndex do
                table.insert(messageParts, parts[i])
            end
            
            -- If you want to join the elements into a single string, you can use:
            local messageString = table.concat(messageParts, " ")
            local co = coroutine.create(function()
                print("Running shout command")
                shout(messageString)
            end)
            coroutine.resume(co)
        else
            print("Unknown command")
        end
    end)


    coroutine.wrap(function()
        while true do
            print_server_status()
            wait(10)
        end
    end)()


else

    
    local function makeEverythingInvisible()
        -- Get all parts in the workspace
        local allParts = game.Workspace:GetDescendants()
    
        -- Iterate through all parts and make them invisible
        for _, part in ipairs(allParts) do
            if part:IsA("BasePart") then
                part.Transparency = 1
            end
        end
    end
    
    makeEverythingInvisible()
    
    

    
    
    
    
    
    
    
    --Gui
    local PLAYER_GUI = PLAYER:WaitForChild("PlayerGui")
    local CORE_GUI = game.CoreGui
    
        
    -- Assuming PLAYER is defined and is the current player
    local PLAYER = game.Players.LocalPlayer

    -- Create LowGfxScreenGui (of 'ScreenGui' class) if it doesn't exist
    if CORE_GUI then
        local LowGfxScreenGui = CORE_GUI:FindFirstChild("LowGfxScreenGui")
        if not LowGfxScreenGui then
            LowGfxScreenGui = Instance.new("ScreenGui")
            LowGfxScreenGui.Name = "LowGfxScreenGui"
            LowGfxScreenGui.Enabled = true -- Set to true by default
            LowGfxScreenGui.IgnoreGuiInset = true
            LowGfxScreenGui.Parent = CORE_GUI

            -- Create LowGfxBackground Frame
            local LowGfxBackground = Instance.new("Frame")
            LowGfxBackground.Name = "LowGfxBackground"
            LowGfxBackground.BorderColor3 = Color3.new(0.105882, 0.164706, 0.207843)
            LowGfxBackground.BackgroundColor3 = Color3.new(0, 0, 0) -- Set background color to black
            LowGfxBackground.Size = UDim2.new(1, 0, 1, 0)
            LowGfxBackground.Parent = LowGfxScreenGui

            -- Create LGFXUIGradient UIGradient
            local LGFXUIGradient = Instance.new("UIGradient")
            LGFXUIGradient.Name = "LGFXUIGradient"
            LGFXUIGradient.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)),
                ColorSequenceKeypoint.new(1, Color3.new(0.176471, 0.176471, 0.176471))
            }
            LGFXUIGradient.Rotation = 290
            LGFXUIGradient.Parent = LowGfxBackground

            -- Create LowGfxTitle TextLabel
            local LowGfxTitle = Instance.new("TextLabel")
            LowGfxTitle.Name = "LowGfxTitle"
            LowGfxTitle.Text = tostring(PLAYER_CASH.Value) -- Initialize with current cash value
            LowGfxTitle.TextColor3 = Color3.new(1, 1, 1) -- White text color
            LowGfxTitle.BackgroundTransparency = 1 -- No background
            LowGfxTitle.Size = UDim2.new(0.2, 0, 0.1, 0) -- Adjust size as needed
            LowGfxTitle.Position = UDim2.new(0.4, 0, 0.05, 0) -- Centered horizontally, adjust vertically as needed
            LowGfxTitle.Font = Enum.Font.SourceSans
            LowGfxTitle.TextScaled = true
            LowGfxTitle.Parent = LowGfxBackground

            -- Connect the function to update the cash text when it changes
            PLAYER_CASH.Changed:Connect(function()
                if LowGfxTitle then
                    LowGfxTitle.Text = tostring(PLAYER_CASH.Value)
                else
                    print("LowGfxTitle not found")
                end
            end)

            -- Create Username TextLabel
            local UsernameLabel = Instance.new("TextLabel")
            UsernameLabel.Name = "UsernameLabel"
            UsernameLabel.Text = PLAYER.Name -- Set to player's username
            UsernameLabel.TextColor3 = Color3.new(1, 1, 1) -- White text color
            UsernameLabel.BackgroundTransparency = 1 -- No background
            UsernameLabel.Size = UDim2.new(0.3, 0, 0.05, 0) -- Adjust size as needed
            UsernameLabel.Position = UDim2.new(0.35, 0, 0.12, 0) -- Centered horizontally below the cash label
            UsernameLabel.Font = Enum.Font.SourceSans
            UsernameLabel.TextScaled = true
            UsernameLabel.Parent = LowGfxBackground

            -- Create ProfilePicture ImageLabel
            local ProfilePicture = Instance.new("ImageLabel")
            ProfilePicture.Name = "ProfilePicture"
            ProfilePicture.Size = UDim2.new(0.1, 0, 0.1, 0) -- Adjust size as needed
            ProfilePicture.Position = UDim2.new(0.45, 0, 0.01, 0) -- Adjust position as needed
            ProfilePicture.BackgroundTransparency = 1 -- No background
            ProfilePicture.Image = "http://www.roblox.com/Thumbs/Avatar.ashx?x=100&y=100&Format=png&userId="..PLAYER.UserId -- Get the player's avatar
            ProfilePicture.Parent = LowGfxBackground
        end

        print("LowGfxScreenGui created and enabled")
    else
        print("CORE_GUI not found")
    end

    


    
    
    local function findPlayer(name)
        if name then
            --If they typed the name exactly, then return that
            if Players:FindFirstChild(name) then return Players[name] end
    
            --Otherwise search for player name match
            name = name:lower()
    
            for _, player in ipairs(Players:GetPlayers()) do
                if name == player.Name:lower():sub(1, #name) then
                    return player
                end
            end
        end
        return nil
    end
    
    
    
        
    -- Assuming PLAYER is defined and is the current player
    local PLAYER = game.Players.LocalPlayer

    -- Create LowGfxScreenGui (of 'ScreenGui' class) if it doesn't exist
    if CORE_GUI then
        local LowGfxScreenGui = CORE_GUI:FindFirstChild("LowGfxScreenGui")
        if not LowGfxScreenGui then
            LowGfxScreenGui = Instance.new("ScreenGui")
            LowGfxScreenGui.Name = "LowGfxScreenGui"
            LowGfxScreenGui.Enabled = true -- Set to true by default
            LowGfxScreenGui.IgnoreGuiInset = true
            LowGfxScreenGui.Parent = CORE_GUI

            -- Create LowGfxBackground Frame
            local LowGfxBackground = Instance.new("Frame")
            LowGfxBackground.Name = "LowGfxBackground"
            LowGfxBackground.BorderColor3 = Color3.new(0.105882, 0.164706, 0.207843)
            LowGfxBackground.BackgroundColor3 = Color3.new(0, 0, 0) -- Set background color to black
            LowGfxBackground.Size = UDim2.new(1, 0, 1, 0)
            LowGfxBackground.Parent = LowGfxScreenGui

            -- Create LGFXUIGradient UIGradient
            local LGFXUIGradient = Instance.new("UIGradient")
            LGFXUIGradient.Name = "LGFXUIGradient"
            LGFXUIGradient.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)),
                ColorSequenceKeypoint.new(1, Color3.new(0.176471, 0.176471, 0.176471))
            }
            LGFXUIGradient.Rotation = 290
            LGFXUIGradient.Parent = LowGfxBackground

            -- Create LowGfxTitle TextLabel
            local LowGfxTitle = Instance.new("TextLabel")
            LowGfxTitle.Name = "LowGfxTitle"
            LowGfxTitle.Text = tostring(PLAYER_CASH.Value) -- Initialize with current cash value
            LowGfxTitle.TextColor3 = Color3.new(1, 1, 1) -- White text color
            LowGfxTitle.BackgroundTransparency = 1 -- No background
            LowGfxTitle.Size = UDim2.new(0.2, 0, 0.1, 0) -- Adjust size as needed
            LowGfxTitle.Position = UDim2.new(0.4, 0, 0.05, 0) -- Centered horizontally, adjust vertically as needed
            LowGfxTitle.Font = Enum.Font.SourceSans
            LowGfxTitle.TextScaled = true
            LowGfxTitle.Parent = LowGfxBackground

            -- Connect the function to update the cash text when it changes
            PLAYER_CASH.Changed:Connect(function()
                if LowGfxTitle then
                    LowGfxTitle.Text = tostring(PLAYER_CASH.Value)
                else
                    print("LowGfxTitle not found")
                end
            end)

            -- Create Username TextLabel
            local UsernameLabel = Instance.new("TextLabel")
            UsernameLabel.Name = "UsernameLabel"
            UsernameLabel.Text = PLAYER.Name -- Set to player's username
            UsernameLabel.TextColor3 = Color3.new(1, 1, 1) -- White text color
            UsernameLabel.BackgroundTransparency = 1 -- No background
            UsernameLabel.Size = UDim2.new(0.3, 0, 0.05, 0) -- Adjust size as needed
            UsernameLabel.Position = UDim2.new(0.35, 0, 0.12, 0) -- Centered horizontally below the cash label
            UsernameLabel.Font = Enum.Font.SourceSans
            UsernameLabel.TextScaled = true
            UsernameLabel.Parent = LowGfxBackground

            -- Create ProfilePicture ImageLabel
            local ProfilePicture = Instance.new("ImageLabel")
            ProfilePicture.Name = "ProfilePicture"
            ProfilePicture.Size = UDim2.new(0.1, 0, 0.1, 0) -- Adjust size as needed
            ProfilePicture.Position = UDim2.new(0.45, 0, 0.01, 0) -- Adjust position as needed
            ProfilePicture.BackgroundTransparency = 1 -- No background
            ProfilePicture.Image = "http://www.roblox.com/Thumbs/Avatar.ashx?x=100&y=100&Format=png&userId="..PLAYER.UserId -- Get the player's avatar
            ProfilePicture.Parent = LowGfxBackground
        end

        print("LowGfxScreenGui created and enabled")
    else
        print("CORE_GUI not found")
    end


    
    print("LowGfxScreenGui created and enabled")
    
    
    local function makeEverythingInvisible()
        -- Get all parts in the workspace
        local allParts = game.Workspace:GetDescendants()
    
        -- Iterate through all parts and make them invisible
        for _, part in ipairs(allParts) do
            if part:IsA("BasePart") then
                part.Transparency = 1
            end
        end
    end
    
    makeEverythingInvisible()
    
    
    
    

    local currencyPostFixes = {
        ["k"] = 1000,
        ["m"] = 1000000,
        ["b"] = 1000000000,
    }
    

    -- Shared flag to control stopping the dropping process
    local stopDropping = false

    function stopDropProcess()
        if is_dropping == true then
            is_dropping = false
            stopDropping = true
        end
    end


    -- Function to reset the stop flag
    function resetDropProcess()
        stopDropping = false
    end

    function dropMoney(money, name)
        is_dropping = true
        local amountString = money
        local limit = tonumber(amountString)
        
        if not limit then
            for postFix, value in pairs(currencyPostFixes) do
                if string.find(amountString, postFix) then
                    local rawNumberString = string.gsub(amountString, postFix, "")
                    local amountNumber = tonumber(rawNumberString)
                    limit = amountNumber * value
                    break
                end
            end
        end
        
        if limit then
            local numberOfAltsInGame = countAltsInGame() -- Number of alts in the game
            local targetdrop = limit / numberOfAltsInGame -- Amount per alt
            local roundedTimestoDrop = math.ceil(targetdrop / 12750)-- Time to drop
            CHAT_EVENT:FireServer("Started dropping " .. tostring(money) .. ", for " .. tostring(name), "All")
            
            local currentValue = 0 
            for i = 1, roundedTimestoDrop do
                if stopDropping then
                    print("Stopped dropping")
                    CHAT_EVENT:FireServer("Stopped Dropping", "All")
                    resetDropProcess()  -- Reset the flag before returning
                    return
                end


                MAIN_EVENT:FireServer("DropMoney", 15000)  -- Fire the server event with a payload of 10000
                
                -- Check the flag frequently even if it's not at the start
                if stopDropping then
                    print("Stopped dropping")
                    CHAT_EVENT:FireServer("Stopped Dropping", "All")
                    resetDropProcess()  -- Reset the flag before returning
                    return
                end
                
                wait(16.5)  
            end
            
            if stopDropping then
                print("Stopped dropping")
                CHAT_EVENT:FireServer("Stopped Dropping", "All")
                resetDropProcess()  -- Reset the flag before returning
                return
            end
            CHAT_EVENT:FireServer("Finshed dropping " .. tostring(money) .. ", for " .. tostring(name), "All")
            print("Finished drop at end aaaaaa")
            is_dropping = false
            resetDropProcess()
        end
    end

    
    
    
    
    function countAltsInGame()
        local alts = getgenv().alts
        local count = 0
    
        -- Iterate through the list of alt IDs
        for _, altID in ipairs(alts) do
            -- Check if the player with the alt ID is in the game
            local player = game.Players:GetPlayerByUserId(altID)
            if player then
                -- If player is found, increment the count
                count = count + 1
            end
        end
    
        -- Return the count of alts in the game
        return count
    end
    
    

    local GC = getconnections or get_signal_cons
        if GC then
            for i,v in pairs(GC(Players.LocalPlayer.Idled)) do
                if v["Disable"] then
                    v["Disable"](v)
                elseif v["Disconnect"] then
                    v["Disconnect"](v)
                end
            end
        end
    print("Ran")
    

    
    
    

    
    wait(20)
    --RunService:Set3dRenderingEnabled(false)
    settings().Rendering.QualityLevel = 1
    UserSettings().GameSettings.MasterVolume = 0
    
    

    
    
    ws:Send(client_id)

    -- Define your WebSocket message handler
    ws.OnMessage:Connect(function(message)
        print("Message received:", message)
        local parts = {}
        
        -- Split the message by spaces and store the parts in the table
        for word in string.gmatch(message, "%S+") do
            table.insert(parts, word)
        end
        
        if parts[1] == "drop" then
            if #parts > 2 then
                local money = parts[2]  -- Get the second part of the message
                local name = parts[3]   -- Get the third part of the message
                
                -- Run the drop command in a coroutine
                local co = coroutine.create(function()
                    print("Drop command received")
                    dropMoney(money, name)
                end)
                coroutine.resume(co)
            else
                print("Invalid drop command format")
            end
        elseif parts[1] == "stop" then
            -- Run the stop command in a coroutine
            local co = coroutine.create(function()
                print("Running stop command")
                stopDropProcess()
            end)
            coroutine.resume(co)
        elseif parts[1] == "setup" then
            local player = parts[2]
            local co = coroutine.create(function()
                print("Running kick player command")
                Kick(player)
            end)
            coroutine.resume(co)
        else
            print("Unknown command")
        end
    end)
    
    

end
